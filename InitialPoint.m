function InfoInitialPoint = InitialPoint(ReadInfo, method, randomPoint, point, coeff)
% InfoInitialPoint = InitialPoint(ReadInfo, useBeta, randomPoint, point, coeff)
% 
% DESCRIPTION
%
%
% REQUIRED INPUTS
%   ReadInfo: a structure generated by 'ReadLayers' function
%
% OPTIONAL INPUTS
%   useBeta: boolean variable (true, false) to use beta deformations.
%   randomPoint: boolean variable (true, false) to use a random initial
%   point.
%   point: an array of [NumLayers,1] of a chosen initial point.
%   coeff: an array of [NumLayers,1] of scalars [0,1] to warp the variable
%   space.
%
% OUTPUTS
%   InfoInitialPoint: a structure containing:
%       -idx: 
%       -SortNormDistance:
%       -coeff:    
%%
    tic

    Rows = ReadInfo.Dimensions(1);
    NumLayers = ReadInfo.Dimensions(2);
    NormalizedClimVar = ReadInfo.NormalizedClimVar;
    Distance = zeros(1, Rows);

    % COMPLETE INPUT
    if nargin < 2
        method = 'coeff';
    end
    if nargin < 3
        randomPoint = true;
    end
    if nargin < 4
        if randomPoint == true
            point = rand(NumLayers, 1);
        else
            idx = randi([0,Rows]);
            point = NormalizedClimVar(:,idx);
        end
    end
    if nargin < 5
        coeff = rand(NumLayers, 1);
    end
    % Generate deformations using linear combinations (coefficient)
    if strcmp(method,'coeff')
        coeff = coeff/sum(coeff);
        point = point.*coeff;
        NormalizedClimVar = NormalizedClimVar.*coeff; 
        for i = 1: Rows
            Distance(i) = norm(point - NormalizedClimVar(:, i))...
            * (2 - corr2(point, NormalizedClimVar(:, i)));
        end
        NormDistance = normalize(Distance, 2, 'range');
    
    end
    % Generate Beta deformations
    if strcmp(method,'beta')
        Deformations = BetaDeformations(NormalizedClimVar,point,NumLayers,Rows);
        NormalizedClimVar = Deformations.ClimVar;
        point = Deformations.NewPoint;
        for i = 1: Rows
            Distance(i) = norm(point - NormalizedClimVar(:, i))...
            * (2 - corr2(point, NormalizedClimVar(:, i)));
        end     
        NormDistance = normalize(Distance, 2, 'range');
    end
    if strcmp(method,'harmonic')
        H = HarmonicDeformations(NormalizedClimVar,NumLayers,2,true);
        NormDistance = 1- H.distances;
    end
    % Calculate distance from initial point to the rest of the pixels.


    NormDistance = 1 - NormDistance;
    [SortNormDistance, idx] = sort(NormDistance, 2, 'descend');
    
    % OUTPUT STORAGE    
    InfoInitialPoint.idx = idx;
    InfoInitialPoint.SortNormDistance = SortNormDistance;
    %InfoInitialPoint.coeff = coeff;

    toc

end