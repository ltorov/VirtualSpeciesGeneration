function InfoInitialPoint = InitialPoint(ReadInfo, method, plotting,randomPoint, point, coeff, limdef)
% InfoInitialPoint = InitialPoint(ReadInfo, method, plotting, randomPoint, point, coeff, limdef)
% 
% DESCRIPTION:
%   Calculates the distance from an initial point to the rest of the pixels
%   in a set of layers. The distance is used to determine the sorting order
%   of the layers for further processing.
%
% REQUIRED INPUTS
%   ReadInfo: a structure generated by 'ReadLayers' function.
%
% OPTIONAL INPUTS:
%   method: a string indicating the method to be used for generating
%           deformations. Possible values are 'coeff', 'beta', and 'harmonic'.
%           Default is 'coeff'.
%   plotting: a boolean variable (true, false) indicating whether to show
%             plots during the deformation process. Default is false.
%   randomPoint: a boolean variable (true, false) indicating whether to use
%                a random initial point. Default is true.
%   point: an array of [NumLayers,1] of a chosen initial point.
%   coeff: an array of [NumLayers,1] of scalars [0,1] to warp the variable
%          space. Default is a random array.
%   limdef: a scalar indicating the number of harmonics to use for
%           generating deformations if 'harmonic' method is used. Default is 
%           2.
%
% OUTPUTS:
%   InfoInitialPoint: a structure containing:
%       -idx: an array of [1, Rows] containing the sorted indices of the layers
%             based on their distance from the initial point.
%       -SortNormDistance: an array of [1, Rows] containing the sorted
%             distances of the layers from the initial point. 

    % Start timer
    tic

    % Read input data
    Rows = ReadInfo.Dimensions(1);
    NumLayers = ReadInfo.Dimensions(2);
    NormalizedClimVar = ReadInfo.NormalizedClimVar;
    Distance = zeros(1, Rows);

    % Check input arguments
    if nargin < 2
        method = 'coeff';
    end
    if nargin < 3
        plotting = false;
    end
    if nargin < 4
        randomPoint = true;
    end
    if nargin < 5
        if randomPoint == true
            point = rand(NumLayers, 1);
        else
            idx = randi([0,Rows]);
            point = NormalizedClimVar(:,idx);
        end
    end
    if nargin < 6
        coeff = rand(NumLayers, 1);
    end
    if nargin < 7
        limdef = 2;
    end
    
    % Perform method based on selected option
    switch method
        case 'coeff'
            % Normalize the coefficients
            coeff = coeff/sum(coeff);
            
            % Multiply the point and the normalized climatic variable by the normalized coefficients
            point = point.*coeff;
            NormalizedClimVar = NormalizedClimVar.*coeff;
            
            % Calculate distance using norm and corr2
            for i = 1: Rows
                Distance(i) = norm(point - NormalizedClimVar(:, i))...
                * (2 - corr2(point, NormalizedClimVar(:, i)));
            end
            
            % Normalize distance and store it in NormDistance
            NormDistance = normalize(Distance, 2, 'range');

        case 'beta'
            % Call the BetaDeformations function and store its output
            Deformations = BetaDeformations(NormalizedClimVar,point,NumLayers,Rows,plotting);
            NormalizedClimVar = Deformations.ClimVar;
            point = Deformations.NewPoint;
            
            % Calculate distance using norm and corr2
            for i = 1: Rows
                Distance(i) = norm(point - NormalizedClimVar(:, i))...
                * (2 - corr2(point, NormalizedClimVar(:, i)));
            end 
            
            % Normalize distance and store it in NormDistance
            NormDistance = normalize(Distance, 2, 'range');

        case 'harmonic'
            % Call the HarmonicDeformations function and store its output
            H = HarmonicDeformations(NormalizedClimVar, NumLayers, limdef, plotting);
            
            % Calculate distance using harmonic distances
            NormDistance = 1 - H.distances;

        otherwise
            % Throw an error if method is not valid
            error('Invalid method');
    end
    
    % Invert the distances
    NormDistance = 1 - NormDistance;
    
    % Sort the distances and store the indices
    [SortNormDistance, idx] = sort(NormDistance, 2, 'descend');
    
    % Store output information
    InfoInitialPoint.idx = idx;
    InfoInitialPoint.SortNormDistance = SortNormDistance;
    
    % Stop timer and output elapsed time
    toc

end
