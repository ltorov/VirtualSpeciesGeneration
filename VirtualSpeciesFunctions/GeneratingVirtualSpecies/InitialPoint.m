function InitialPoint = InitialPoint(Layers, method, plotting, random_point, point, coeff, deformations_limit)
%   InitialPoint = InitialPoint(layers, method, plotting, random_point, point, coeff, deformations_limit)
% 
% DESCRIPTION:
%   Calculates the distance from an initial point to the rest of the pixels
%   in a set of layers. The distance is used to determine the sorting order
%   of the layers for further processing.
%
% REQUIRED INPUTS
%   Layers: a structure generated by 'ReadLayers' function.
%
% OPTIONAL INPUTS:
%   method: a string indicating the method to be used for generating
%           deformations. Possible values are 'coeff', 'beta', and 'harmonic'.
%           Default is 'coeff'.
%   plotting: a boolean variable (true, false) indicating whether to show
%             plots during the deformation process. Default is false.
%   random_point: a boolean variable (true, false) indicating whether to use
%                 a random initial point. Default is true.
%   point: an array of [layer_num,1] of a chosen initial point.
%   coeff: an array of [layer_num,1] of scalars [0,1] to warp the variable
%          space. Default is a random array.
%   deformations_limit: a scalar indicating the number of harmonics to use 
%                       for generating deformations if 'harmonic' method is 
%                       used. Default is 2.
%
% OUTPUTS:
%   InitialPoint: a structure containing:
%       -idx: an array of [1, Rows] containing the sorted indices of the layers
%             based on their distance from the initial point.
%       -SortNormDistance: an array of [1, Rows] containing the sorted
%             distances of the layers from the initial point. 

    % Start timer
    tic

    % Read input data
    rows = Layers.Dimensions(1);
    layer_num = Layers.Dimensions(2);
    norm_climate_vars = Layers.NormalizedClimVar;
    distance = zeros(1, rows);

    % Check input arguments
    if nargin < 2
        method = 'coeff';
    end
    if nargin < 3
        plotting = false;
    end
    if nargin < 4
        random_point = true;
    end
    if nargin < 5
        if random_point == true
            point = rand(layer_num, 1);
        else
            idx = randi([0,rows]);
            point = norm_climate_vars(:,idx);
        end
    end
    if nargin < 6
        coeff = rand(layer_num, 1);
    end
    if nargin < 7
        deformations_limit = 2;
    end
    
    % Perform method based on selected option
    switch method
        case 'coeff'
            % Normalize the coefficients
            coeff = coeff/sum(coeff);
            
            % Multiply the point and the normalized climatic variable by the normalized coefficients
            point = point.*coeff;
            norm_climate_vars = norm_climate_vars.*coeff;
            
            % Calculate distance using norm and corr2
            for i = 1: rows
                distance(i) = norm(point - norm_climate_vars(:, i))...
                * (2 - corr2(point, norm_climate_vars(:, i)));
            end
            
            % Normalize distance and store it in norm_distance
           norm_distance = normalize(distance, 2, 'range');

        case 'beta'
            % Call the BetaDeformations function and store its output
            beta_deformations = BetaDeformations(norm_climate_vars,point,layer_num,rows,plotting);
            norm_climate_vars = beta_deformations.ClimVar;
            point = beta_deformations.NewPoint;
            
            % Calculate distance using norm and corr2
            for i = 1: rows
                distance(i) = norm(point - norm_climate_vars(:, i))...
                * (2 - corr2(point, norm_climate_vars(:, i)));
            end 
            
            % Normalize distance and store it in norm_distance
            norm_distance = normalize(distance, 2, 'range');

        case 'harmonic'
            % Call the HarmonicDeformations function and store its output
            H = HarmonicDeformations(norm_climate_vars, layer_num, deformations_limit, plotting);
            
            % Calculate distance using harmonic distances
            norm_distance = 1 - H.Distances;

        otherwise
            % Throw an error if method is not valid
            error('Invalid method');
    end
    
    % Invert the distances
    norm_distance = 1 - norm_distance;
    
    % Sort the distances and store the indices
    [sorted_norm_distance, idx] = sort(norm_distance, 2, 'descend');
    
    % Store output information
    InitialPoint.idx = idx;
    InitialPoint.SortNormDistance = sorted_norm_distance;
    
    % Stop timer and output elapsed time
    toc

end
